# JPA
## JPA란?

- 자바 ORM 기술에 대한 표준 명세로, JAVA에서 제공하는 API이다. 스프링에서 제공하는것이 아니다.
- 자바 어플리케이션에서 관계형 데이터베이스를 사용하는 방식을 정의한 인터페이스다.
- 여기서 중요한건 JPA는 말 그대로 인터페이스이다.JPA는 특정 기능을 하는 라이브러리가 아니다. 스프잉의 PSA에 의해서(POJO를 사용하면서 특정 기술을 사용하기 위해서)표준 인터페이스를 정해두었는데, 그중 ORM을 사용하기 위해 만든 인터페이스가 바로 JPA이다.
- 기존 EJB에서 제공되던 엔티티 빈을 대체하는 기술이다.
- **ORM이기 때문에 자바 클래스와 DB테이블을 매핑한다.(SQL을 매핑하지않는다)**
- ORM을 사용하기 위한 인터페이스를 모아둔 것이며, JPA를 사용하기 위해서는 JPA를 구현한 Hibernate, EclipseLink, DataNucleus같은 ORM 프레임워크를 사용해야 합니다.

## 그러면 ORM이란?

ORM (Object-Relational Mapping)은 객체 지향 프로그래밍 언어를 사용하여 호환되지 않는 유형의 시스템 간에 데이터를 변환하는 프로그래밍 기술입니다. 즉, **ORM은 데이터베이스의 데이터를 객체로 변환하여, 프로그래머가 객체 지향 언어로 데이터베이스를 더 쉽게 다룰 수 있게 해 줍니다.** 이를 통해 개발자는 데이터베이스의 데이터를 마치 자신의 언어 내의 일반 객체처럼 조작할 수 있어, 데이터베이스와의 상호 작용을 추상화하여 복잡성을 감소시킵니다.

JPA (Java Persistence API)는 Java EE 플랫폼에서 제공하는 ORM 구현체의 표준 인터페이스를 제공합니다. JPA를 사용하면 개발자는 데이터베이스 테이블을 Java 클래스로 매핑하고, 데이터베이스 연산을 Java 객체의 CRUD (생성, 조회, 업데이트, 삭제) 연산으로 처리할 수 있습니다.


## Hibernate 는 뭔데?

Hibernate는 ORM (Object-Relational Mapping)의 구현체 중 하나이며, Java 언어에서 가장 널리 사용되는 ORM 프레임워크 중 하나입니다. ORM 프레임워크는 객체 지향 모델과 관계형 데이터베이스를 연결하는 역할을 하며, Hibernate는 이러한 작업을 용이하게 해줍니다.

### **Hibernate의 주요 기능**

1. **데이터베이스 독립성**:
    - Hibernate는 다양한 데이터베이스를 지원합니다. 이를 통해 개발자는 특정 데이터베이스에 종속되지 않고 데이터 액세스 로직을 구현할 수 있습니다.
2. **자동 테이블 생성**:
    - Hibernate는 엔티티 클래스에 기반한 데이터베이스 테이블을 자동으로 생성할 수 있는 기능을 제공합니다. 이를 통해 데이터베이스 스키마 관리가 간소화됩니다.
3. **캐싱**:
    - 성능 최적화를 위해 내부적으로 캐싱 메커니즘을 제공합니다. 이는 자주 사용되는 데이터의 빠른 접근을 가능하게 하여 성능을 향상시킵니다.
4. **트랜잭션 관리**:
    - Hibernate는 선언적 트랜잭션 관리를 지원하며, JPA와 함께 사용될 때 Java EE 표준의 트랜잭션 관리와도 잘 통합됩니다.
5. **HQL (Hibernate Query Language)**:
    - Hibernate는 SQL을 추상화한 자체 쿼리 언어인 HQL을 제공합니다. HQL은 데이터베이스 테이블이 아닌 엔티티 객체를 대상으로 쿼리를 작성할 수 있게 해 줍니다.
6. **Criteria API**:
    - 프로그래밍 방식으로 쿼리를 구성할 수 있는 Criteria API를 제공합니다. 이는 복잡한 검색 기능을 구현할 때 유용합니다.

### **Hibernate와 JPA**

Hibernate는 JPA의 구현체 중 하나로, JPA가 정의한 표준을 따르는 라이브러리입니다. JPA 인터페이스를 구현함으로써, Hibernate는 Java 개발자가 데이터베이스와 상호 작용하는 표준 방식을 제공합니다. 따라서 개발자는 Hibernate를 사용하여 JPA 표준에 따른 데이터 접근과 관리를 할 수 있으며, 필요에 따라 다른 JPA 구현체로 쉽게 전환할 수 있습니다.

이런 특징들 덕분에 Hibernate는 대규모 엔터프라이즈 애플리케이션에서 매우 인기 있는 선택지가 되고 있습니다.

## 스프링 데이터 JPA

**스프링 데이터 JPA**는 Spring Framework의 일부로서, Java Persistence API (JPA)를 사용하는 데이터 액세스 계층을 더욱 쉽게 구현할 수 있도록 지원하는 모듈입니다. 이 모듈은 개발자가 데이터베이스 작업을 보다 효율적이고 간단하게 처리할 수 있도록 다양한 편의 기능을 제공합니다. 스프링 데이터 JPA를 사용하면, JPA를 기반으로 하는 저장소를 손쉽게 설정하고, 데이터 접근을 위한 반복 코드를 대폭 줄일 수 있습니다.

### **스프링 데이터 JPA의 주요 기능**

1. **레포지토리 추상화**:
    - 스프링 데이터 JPA는 인터페이스 기반의 프로그래밍 모델을 제공하여, 기본적인 CRUD 연산을 위한 메소드를 자동으로 구현합니다. 개발자는 간단히 인터페이스를 정의하면, 스프링 데이터 JPA가 실행 시점에 이를 구현체로 변환하여 사용할 수 있게 해 줍니다.
2. **쿼리 메소드**:
    - 메소드 이름만으로 쿼리를 자동으로 생성하는 기능을 제공합니다. 예를 들어, **`findByName`** 메소드를 정의하면, 이 메소드는 자동으로 해당 이름을 가진 엔티티를 검색하는 쿼리를 생성하고 실행합니다.
3. **쿼리 어노테이션**:
    - **`@Query`** 어노테이션을 사용하여 JPQL 또는 SQL 쿼리를 직접 정의할 수 있습니다. 이를 통해 복잡한 쿼리도 쉽게 처리할 수 있습니다.
4. **페이징과 정렬**:
    - 스프링 데이터 JPA는 페이징과 정렬을 지원하는 간단한 방법을 제공합니다. **`Pageable`** 인터페이스와 **`Sort`** 클래스를 사용하여, 데이터를 페이징하고 정렬하는 작업을 쉽게 구현할 수 있습니다.
5. **트랜잭션 관리**:
    - 스프링 프레임워크의 선언적 트랜잭션 관리를 지원합니다. **`@Transactional`** 어노테이션을 메소드나 클래스에 적용함으로써, 해당 영역의 코드를 트랜잭션 범위 내에서 실행할 수 있습니다.
6. **감사(Auditing)**:
    - 엔티티의 생성 시간, 수정 시간, 생성자, 수정자 등을 자동으로 관리할 수 있는 기능을 제공합니다. 이를 위해 **`@CreatedDate`**, **`@LastModifiedDate`**, **`@CreatedBy`**, **`@LastModifiedBy`** 등의 어노테이션을 사용할 수 있습니다.

### **JPA 작동 흐름도**

JPA의 주요 작동 흐름은 다음과 같습니다:

```
+-------------------+
| 1. 엔티티 클래스 정의 |
+-------------------+
        |
        | 데이터베이스 테이블을 Java 클래스로 매핑
        V
+---------------------+
| 2. EntityManager 설정 |
+---------------------+
        |
        | EntityManagerFactory 생성 후 EntityManager 인스턴스 생성
        V
+-------------------+
| 3. 트랜잭션 관리   |
+-------------------+
        |
        | 트랜잭션 시작, 커밋, 롤백
        V
+-------------------+
| 4. CRUD 연산 수행  |
+-------------------+
        |
        | 생성, 조회, 업데이트, 삭제
        V
+---------+
| 5. 캐싱  |
+---------+
        |
        | 성능 최적화를 위해 일차 캐시 사용
        V
+------------------------+
| 6. 동기화 및 커밋       |
+------------------------+
        |
        | 트랜잭션 커밋 시 변경된 내용 데이터베이스에 동기화

```

1. **엔티티 클래스 정의**:
    - 데이터베이스 테이블을 반영하는 Java 클래스를 정의합니다. 이 클래스를 엔티티라고 하며, 각 인스턴스는 테이블의 한 행(row)에 해당합니다.
2. **EntityManager 설정**:
    - `EntityManagerFactory`를 생성하고 이를 사용하여 **`EntityManager`** 인스턴스를 생성합니다. `EntityManager`는 엔티티를 관리하고, 데이터베이스 연산을 수행하는 주된 객체입니다.
3. **트랜잭션 관리**:
    - 데이터베이스 연산을 수행할 때, 이러한 연산들을 트랜잭션 단위로 그룹화합니다. `EntityManager`를 사용하여 트랜잭션을 시작하고, 종료(커밋)하거나 실패 시 롤백합니다.
4. **CRUD 연산 수행**:
    - **`EntityManager`**를 통해 엔티티 객체를 생성, 조회, 업데이트, 삭제하는 등의 데이터베이스 연산을 수행합니다.
    - 조회는 JPQL (Java Persistence Query Language) 또는 Criteria API를 사용하여 수행될 수 있습니다.
5. **캐싱**:
    - JPA는 성능 최적화를 위해 일차 캐시를 사용하여, 한 트랜잭션 내에서의 엔티티 반복 접근을 최적화합니다.
6. **동기화 및 커밋**:
    - 트랜잭션이 커밋되면 변경된 내용이 데이터베이스에 동기화됩니다. 엔티티의 변경 사항이 자동으로 데이터베이스에 반영됩니다.


## 주요 용어

### **1. 엔티티 (Entity)**

엔티티는 데이터베이스 테이블의 행을 객체 지향 방식으로 표현한 것입니다. 엔티티 클래스라고도 하며, **`@Entity`** 어노테이션을 사용하여 클래스를 엔티티로 지정합니다. 각 엔티티 인스턴스는 데이터베이스의 행에 대응되며, 이들은 보통 키값을 가지는데, 이는 **`@Id`** 어노테이션으로 표시됩니다.

### **2. 영속성 (Persistence)**

영속성이란 데이터가 프로그램이 종료된 후에도 사라지지 않고 지속되는 성질을 말합니다. JPA에서는 이러한 영속성을 관리하여 애플리케이션이 데이터베이스의 데이터를 사용하고 관리할 수 있도록 합니다.

영속성을 갖지 않으면 데이터는 메모리에서만 존재하게 되고 프로그램이 종료되면 해당 데이터는 모두 사라지게 된다.

그래서 우리는 데이터를 파일이나 DB에 영구 저장함으로써 데이터에 영속성을 부여한다.

### **3. 영속성 컨텍스트 (Persistence Context)**
```
┌────────────────────────────────────────────────────────────────┐
│                          영속성 컨텍스트                       │
│                                                                │
│  ┌──────────────┐   ┌──────────────┐   ┌──────────────┐        │
│  │  비영속      │   │   영속       │   │  준영속      │        │
│  │ (Transient)  │──▶│ (Persistent) │──▶│ (Detached)  │        │
│  └──────────────┘   └──────────────┘   └──────────────┘        │
│         │                   │                   │              │
│         │                   │                   │              │
│         ▼                   │                   │              │
│  ┌──────────────┐           │                   │              │
│  │    삭제       │           │                   │              │
│  │ (Removed)    │           │                   │              │
│  └──────────────┘           │                   │              │
│         ▲                   │                   │              │
│         └───────────────────┴───────────────────┘              │
│                                                                │
└────────────────────────────────────────────────────────────────┘

설명:
1. 비영속 (Transient): 영속성 컨텍스트에 의해 관리되지 않는 상태.
   - 예시: new Entity()

2. 영속 (Persistent): 영속성 컨텍스트에 의해 관리되는 상태.
   - 예시: entityManager.persist(entity)

3. 준영속 (Detached): 영속성 컨텍스트에 의해 더 이상 관리되지 않는 상태.
   - 예시: entityManager.detach(entity)

4. 삭제 (Removed): 영속성 컨텍스트에서 삭제된 상태.
   - 예시: entityManager.remove(entity)

```
영속성 컨텍스트는 엔티티를 영구 저장하는 환경입니다. `EntityManager`를 통해 엔티티가 관리되며, 이 컨텍스트 내에서 엔티티의 생명주기가 관리됩니다. 영속성 컨텍스트는 엔티티의 인스턴스를 유일하게 식별하고, 일차 캐시, 변경 감지, 지연 로딩 등의 장점을 제공합니다.

**영속성 컨텍스트와 관련한 엔티티의 4가지 상태**

1. 비영속(new/transient) - 엔티티 객체가 만들어져서 아직 저장되지 않은 상태로, 영속성 컨텍스트와 전혀 관계가 없는 상태

2. 영속(managed) - 엔티티가 영속성 컨텍스트에 저장되어, 영속성 컨텍스트가 관리할 수 있 는 상태

3. 준영속(detached) - 엔티티가 영속성 컨텍스트에 저장되어 있다가 분리된 상태로, 영속성 컨텍스트가 더 이상 관리하지 않는 상태

4. 삭제(removed) - 엔티티를 영속성 컨텍스트와 데이터베이스에서 삭제

### **영속성 컨텍스트의 특징**

1. 영속성 컨텍스트는 엔티티를 식별자 값(@Id로 테이블의 기본키와 매핑한 필드 값)으로 구분 한다. 그렇기 때문에 영속 상태는 식별자 값이 반드시 있어야 한다.

2. 영속성 컨텍스트에 엔티티를 저장하면 바로 데이터베이스에 저장되는 것이 아니라, 1차 캐시 에 엔티티를 생성하고, 쓰기 지연 SQL 저장소에 쿼리문을 생성해서 저장한다. 이렇게 쌓인 쿼리문은 flush( )가 실행될 때 데이터베이스에 반영된다.

### **4. 영속성 레이어 (Persistence Layer)**

영속성 레이어는 데이터베이스와 상호작용하는 애플리케이션의 계층으로, 데이터를 영구 저장하는 책임을 집니다. JPA는 이 계층을 구현하기 위한 표준 방식을 제공합니다.

### **5. 엔티티 매니저 (EntityManager)**

`EntityManager`는 JPA의 핵심 클래스로, **엔티티에 대한 데이터베이스 연산을 수행**합니다. 엔티티 매니저는 영속성 컨텍스트를 통해 엔티티의 생명주기를 관리합니다.

### **6. 엔티티 매니저 팩토리 (EntityManagerFactory)**

`EntityManagerFactory`는 **`EntityManager`** 인스턴스를 생성합니다. 이는 일반적으로 애플리케이션 전체에서 단 하나만 존재하며, 비용이 많이 드는 객체입니다.

### **7. 트랜잭션 (Transaction)**

데이터베이스의 상태를 변경하는 작업을 안전하게 수행하기 위해, 이 작업들을 트랜잭션 단위로 그룹화합니다. JPA에서는 **`EntityTransaction`** 인터페이스를 통해 트랜잭션을 관리합니다.

### **8. JPQL (Java Persistence Query Language)**

JPQL은 데이터베이스 테이블이 아닌 엔티티 객체를 대상으로 하는 쿼리 언어입니다. SQL과 유사하지만, 데이터베이스 테이블 대신 엔티티 클래스와 그 속성을 사용하여 쿼리를 작성합니다.
  
## JPA에서의 영속성  
```
┌───────────────────────────┐        ┌──────────────────────┐        ┌──────────────┐
│      응용 프로그램       │        │      영속 컨텍스트     │        │     DB       │
│                           │        │                      │        │              │
│  ┌──────────────┐         │        │  ┌──────────────┐    │        │  ┌──────────┐ │
│  │ 엔티티 객체  │         │ ─────▶ │  │ 영속 객체    │    │ ─────▶ │  │ 레코드   │ │
│  └──────────────┘         │        │  └──────────────┘    │        │  └──────────┘ │
│  ┌──────────────┐         │ ◀───── │  ┌──────────────┐    │ ◀───── │  ┌──────────┐ │
│  │ 엔티티 객체  │         │        │  │ 영속 객체    │    │        │  │ 레코드   │ │
│  └──────────────┘         │        │  └──────────────┘    │        │  └──────────┘ │
└───────────────────────────┘        └──────────────────────┘        └──────────────┘

```
JPA의 핵심 내용은 엔티티가 영속성 컨텍스트에 포함되어 있냐 아니냐로 갈린다.

JPA의 엔티티 매니저가 활성화된 상태로 트랜잭션(@Transactional) 안에서 DB에서 데이터를 가져오면 이 데이터는 영속성 컨텍스트가 유지된 상태이다. 이 상태에서 해당 데이터 값을 변경하면 트랜잭션이 끝나는 시적에 해당 테이블에 변경 내용을 반영하게 된다. 따라서 우리는 앤티티 객체의 필드 값만 변경해주면 별도로 update()쿼리를 날릴 필요가 없게 된다! 이 개념을 더티 체킹이라고 한다

## JPA 엔티티 어노테이션

### **1. `@Entity`**

- **`@Entity`** 어노테이션은 클래스가 JPA 엔티티임을 나타냅니다. 이 어노테이션을 사용한 클래스는 데이터베이스 테이블에 매핑되며, 클래스의 인스턴스는 해당 테이블의 행에 해당합니다.

### **2. `@Table`**

- **`@Table`** 어노테이션은 엔티티 클래스와 매핑할 데이터베이스 테이블의 정보를 제공합니다. 예를 들어, 테이블의 이름, 카탈로그, 스키마 등을 지정할 수 있습니다.
- 예: **`@Table(name = "users")`**

### **3. `@Id`**

- **`@Id`** 어노테이션은 엔티티의 기본 키(primary key) 필드를 지정합니다. 각 엔티티는 반드시 하나 이상의 @Id를 가지고 있어야 합니다.

### **4. `@GeneratedValue`**

- **`@GeneratedValue`** 어노테이션은 기본 키의 값을 자동으로 생성할 방법을 지정합니다. 예를 들어, 데이터베이스의 auto-increment 기능을 사용할 수 있습니다.

### **5. `@Column`**

- **`@Column`** 어노테이션은 엔티티의 필드가 데이터베이스 테이블의 어떤 칼럼과 매핑될지를 정의합니다. 이를 통해 칼럼명, 길이, 널 허용 여부 등을 세밀하게 지정할 수 있습니다.

### **6. `@Transient`**

- **`@Transient`** 어노테이션은 해당 필드가 데이터베이스 테이블의 칼럼과 매핑되지 않음을 나타냅니다. 즉, 이 필드는 데이터베이스에 저장되거나 검색되지 않습니다.

### **7. `@ManyToOne` 및 `@OneToMany`**

- 이 어노테이션들은 엔티티 간의 관계를 정의합니다. **`@ManyToOne`**은 많은 엔티티가 하나의 엔티티와 관련될 때 사용되며, **`@OneToMany`**는 하나의 엔티티가 여러 엔티티와 관련될 때 사용됩니다.

### **8. `@JoinColumn`**

- **`@JoinColumn`** 어노테이션은 두 엔티티를 연결하는 외래 키(foreign key) 칼럼을 지정할 때 사용됩니다.

### **9. `@ManyToMany`**

- **`@ManyToMany`** 어노테이션은 엔티티 간의 다대다 관계를 정의할 때 사용됩니다. 이 경우, 관계를 관리하기 위한 연결 테이블이 필요합니다.

### **10. `@Version`**

- **`@Version`** 어노테이션은 엔티티의 버전 관리를 위해 사용됩니다. 이는 동시성 제어에 유용하며, 데이터베이스에 엔티티를 저장할 때 충돌을 방지하는 데 도움이 됩니다.